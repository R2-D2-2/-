'use strict'; 
//Небольшое задание
//alert ("«Я JavaScript!»");
//ctrl + / закоментировать кусочек кода

//Переменные let с именем user... var почти тоже, что и let, но устаревший вариант.
let user = 'John',
    age = 25,
    message = 'Hello';

let hello = 'Hello world!';

let message2;

// копируем значение 'Hello world' из переменной hello в переменную message
message2 = hello;

//const неизменяемая переменная. Часто используют для заранее известных цветов. const COLOR_RED = "#F00"; Для упрощения записи.
const num = '25';

//Небольшое задание
// let name = "Джон",
//     admin = name;
//     alert (admin);



// 25.02.23
// Число.
let age3 = 25;
// Строка.
let age4 = "25";
// Булевое значение.
let age5 = true;
let age6 = false;
// Значение null.
let age7 = null;
// Значение undefined. Значение не было присвоено.
let age8;
// Оператор typeof. Похоже показывает каким типом объекта является предмет.
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)



// Взаимодействие alert, prompt, confirm
// prompt Даёт в обработку данные введёные пользователем.

// let age9 = prompt('Сколько тебе лет?', 100);

// alert(`Тебе ${age9} лет!`); // Тебе 100 лет!

// confirm Окно с выбором Ок или Отмена ответ: true else false.
// let isBoss = confirm("Ты здесь главный?");
// alert( isBoss );

// Небольшое задание
// let nameUzer = prompt('Как вас зовут?');
// alert(`Добрый день, ${nameUzer}!`);



// string Строковое преобразование. 
// let value = true;
// alert(typeof value); // boolean

// value = String(value); // теперь value это строка "true"
// alert(typeof value); // string

// Number Численное преобразование.
// let str = "123";
// alert(typeof str); // string

// let num3 = Number(str); // становится числом 123

// alert(typeof num3); // number
// Примеры:
// alert( Number("   123   ") ); // 123
// alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
// alert( Number(true) );        // 1
// alert( Number(false) );       // 0

// Boolean Логическое преобразование.
// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true.
// Например:
// alert( Boolean(1) ); // true
// alert( Boolean(0) ); // false

// alert( Boolean("Привет!") ); // true
// alert( Boolean("") ); // false

// Сложение строк при помощи бинарного +
// let s = "моя" + "строка";
// alert(s); // моястрока
// alert(2 + 2 + '1' ); // будет "41", а не "221"

// Волшебный +
// Преобразует не числа в числа
// alert( +true ); // 1
// alert( +"" );   // 0
// На самом деле это то же самое, что и Number(...), только короче.

// Сокращённая арифметика с присваиванием.
// let n = 2;
// n += 5; // теперь n = 7 (работает как n = n + 5)
// n *= 2; // теперь n = 14 (работает как n = n * 2)

// alert( n ); // 14

// Странная разница.
// let counter = 1;
// let a = ++counter; // (*)

// alert(a); // 2

// let counter = 1;
// let a = counter++; // (*) меняем ++counter на counter++

// alert(a); // 1

//Поддерживаются следующие побитовые операторы:

// AND(и) ( & )
// OR(или) ( | )
// XOR(побитовое исключающее или) ( ^ )
// NOT(не) ( ~ )
// LEFT SHIFT(левый сдвиг) ( << )
// RIGHT SHIFT(правый сдвиг) ( >> )
// ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

// Оператор запятая. Запятая имеет очень низкий приоритет, ниже чем =.
// let a = (1 + 2, 3 + 4);

// alert( a ); // 7 (результат вычисления 3 + 4)

// Сложение с участием пользователя.
// let a = prompt("Первое число?", 1);
// let b = prompt("Второе число?", 2);

// alert(+a + +b); // 3



// Операторы сравнения.
// Операторы сравнения такие же как и в математике, есть особенности.
// Результат сравнения имеет логический тип.
// Например:
// alert( 2 > 1 );  // true (верно)
// alert( 2 == 1 ); // false (неверно)
// alert( 2 != 1 ); // true (верно)

// let result = 5 > 4; // результат сравнения присваивается переменной result
// alert( result ); // true

// Сравнение строк.
// alert( 'Я' > 'А' ); // true
// alert( 'Коты' > 'Кода' ); // true
// alert( 'Сонный' > 'Сон' ); // true

// При сравнении значений разных типов JavaScript приводит каждое из них к числу.
// alert( '2' > 1 ); // true, строка '2' становится числом 2
// alert( '01' == 1 ); // true, строка '01' становится числом 1
// alert( 0 === false ); // false, так как сравниваются разные типы

// 5 > 4 → true
// "ананас" > "яблоко" → false
// "2" > "12" → true
// undefined == null → true
// undefined === null → false
// null == "\n0\n" → false
// null === +"\n0\n" → false
// Разъяснения:

// Очевидно, true.
// Используется посимвольное сравнение, поэтому false. "а" меньше, чем "я".
// Снова посимвольное сравнение. Первый символ первой строки "2" больше, чем первый символ второй "1".
// Специальный случай. Значения null и undefined равны только друг другу при нестрогом сравнении.
// Строгое сравнение разных типов, поэтому false.
// Аналогично (4), null равен только undefined.
// Строгое сравнение разных типов.



// Условное ветвление: if.
// let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

// if (year == 2015) alert( 'Вы правы!' );

// if (year == 2015) {
//     alert( "Правильно!" );
//     alert( "Вы такой умный!" );
//   }

// Блок «else».
// let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

// if (year == 2015) {
//   alert( 'Да вы знаток!' );
// } else {
//   alert( 'А вот и неправильно!' ); // любое значение, кроме 2015
// }

// let year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '');

// if (year < 2015) {
//   alert( 'Это слишком рано...' );
// } else if (year > 2015) {
//   alert( 'Это поздновато' );
// } else {
//   alert( 'Верно!' );
// }

// Условный оператор „?“
// let result = условие ? значение1 : значение2;
// let accessAllowed = (age > 18) ? true : false;
// let age = prompt('Возраст?', 18);

// let message = (age < 3) ? 'Здравствуй, малыш!' :
//   (age < 18) ? 'Привет!' :
//   (age < 100) ? 'Здравствуйте!' :
//   'Какой необычный возраст!';

// alert( message );

// Небольшое задание.

// let nameUz = prompt('Какое "официальное" название JavaScript?', '');

// if (nameUz == "ECMAScript") {
//     alert( "Верно!" );
//     }
// else {
//     alert( "Не знаете? “ECMAScript”!" );
//     }

// Небольшое задание.

// let num5 = +prompt('Введите число:', '');

// if (num5 == 0) {
//     alert (0);
// }
// else if (num5 > 0) {
//     alert (1);
// }
// else {
//     alert (-1);
// }

// Небольшое задание.

// let a = 2;
// let b = 3;
// let result = (a + b < 4) ? 'Мало':'Много';
// alert(result);

// Небольшое задание.

// let login1 = prompt('Введите логин:', '');

// let message3 = (login1 == 'Сотрудник') ? 'Привет':
// (login1 == 'Директор') ? 'Здравствуйте':
// (login1 == '') ? 'Нет логина':
// ' ';

// alert (message3);



// Логические операторы.

// || или.
// result = a || b;

// Существует всего четыре возможные логические комбинации с булевыми значениями:
// alert( true || true );   // true
// alert( false || true );  // true
// alert( true || false );  // true
// alert( false || false ); // false

// Если значение не логического типа, то оно к нему приводится в целях вычислений.
// if (1 || 0) { // работает как if( true || false )
//     alert( 'truthy!' );
//   }

// let hour = 12;
// let isWeekend = true;

// if (hour < 10 || hour > 18 || isWeekend) {
//   alert( 'Офис закрыт.' ); // это выходной
// }

// ИЛИ "||" находит первое истинное значение
// result = value1 || value2 || value3;
// Оператор || выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
// Если все операнды являются ложными (false), возвращает последний из них.

// Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

// let x;

// true || (x = 1);

// alert(x); // undefined, потому что (x = 1) не вычисляется

// let x;

// false || (x = 1);

// alert(x); // 1

// && (И)
// result = a && b;

// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:
// alert( true && true );   // true
// alert( false && true );  // false
// alert( true && false );  // false
// alert( false && false ); // false

// Пример:
// let hour = 12;
// let minute = 30;

// if (hour == 12 && minute == 30) {
//     alert( 'The time is 12:30' );
// }

// И «&&» находит первое ложное значение.
// result = value1 && value2 && value3;
// Оператор && выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.
// Если все операнды были истинными, возвращается последний.

// Когда все значения верны, возвращается последнее

// alert( 1 && 2 && 3 ); // 3
// Работает как обратное ИЛИ.
// Приоритет оператора && больше, чем у ||

// let x = 1;

// (x > 0) && alert( 'Greater than zero!' );

// ! (НЕ)
//result = !value;

// Оператор принимает один аргумент и выполняет следующие действия:

// Сначала приводит аргумент к логическому типу true/false.
// Затем возвращает противоположное значение.

// Например:

// alert( !true ); // false
// alert( !0 ); // true

// В частности, двойное НЕ !! используют для преобразования значений к логическому типу:

// alert( !!"non-empty string" ); // true
// alert( !!null ); // false

// Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

// Небольшое задание.

// alert( alert(1) || 2 || alert(3) );
// Решение: выведет 1, а затем 2.
// Вызов alert не возвращает значения, или, иначе говоря, возвращает undefined.

// let age10 = !!null;
// alert(age10);

// let age11 = !!undefined;
// alert(age11);

// // В логическом виде оба выдают false.

// let age12 = 1;
// if (age10 == age11) {
//     alert(age12);
// }
// else {
//     alert(0);
// }

// Возвращение блудного сына. 06.03.23
// Оператор нулевого слияния (??)

// result = a ?? b
// Определяет значение: если a определено, то a,
// если a не определено, то b.
// Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:
// result = (a !== null && a !== undefined) ? a : b;

// Например:

// let user;
// alert(user ?? "Аноним");

// let user = "Иван";
// alert(user ?? "Аноним"); // Иван (user существует)

// let firstName = null;
// let lastName = null;
// let nickName = "Суперкодер";

// показывает первое значение, которое определено:
// alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

// Приоритет оператора ?? такой же, как и у ||.

// По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

// Циклы while и for.

// Для многократного повторения одного участка кода предусмотрены циклы.

// Цикл «while»
// Цикл while имеет следующий синтаксис:

// while (condition) {
//   // код
//   // также называемый "телом цикла"
// }

// Код из тела цикла выполняется, пока условие condition истинно.

// let i = 0;
// while (i < 3) { // выводит 0, затем 1, затем 2
//   alert( i );
//   i++;
// }

// Цикл «do…while»

// do {
//   // тело цикла
// } while (condition);

// Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

// let i = 0;
// do {
//   alert( i );
//   i++;
// } while (i < 3);

// Цикл «for».

// for (начало; условие; шаг) {
// ... тело цикла ...
// }

// for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
//   alert(i);
// }

// В примере переменная счётчика i была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.

// for (let i = 0; i < 3; i++) {
//   alert(i); // 0, 1, 2
// }
// alert(i); // ошибка, нет такой переменной

// Прерывание цикла: «break»

// let sum = 0;

// while (true) {

//   let value = +prompt("Введите число", '');

//   if (!value) break; // (*)

//   sum += value;

// }
// alert( 'Сумма: ' + sum );

// Похоже на часть калькулятора.

// Переход к следующей итерации: continue

// Например, цикл ниже использует continue, чтобы выводить только нечётные значения:

// for (let i = 0; i < 10; i++) {

//   // если true, пропустить оставшуюся часть тела цикла
//   if (i % 2 == 0) continue;

//   alert(i); // 1, затем 3, 5, 7, 9
// }

// Метки для break/continue.
// labelName: for (...) {
//   ...
// }

// outer: for (let i = 0; i < 3; i++) {

//     for (let j = 0; j < 3; j++) {
  
//       let input = prompt(`Значение на координатах (${i},${j})`, '');
  
//       // если пустая строка или Отмена, то выйти из обоих циклов
//       if (!input) break outer; // (*)
  
//       // сделать что-нибудь со значениями...
//     }
//   }
  
//   alert('Готово!');

// Небольшое задание.
// for (let i = 2; i <= 10; i++) {
//     if (i % 2 == 0) {
//       alert( i );
//     }
//   }

// Небольшое задание.
// let i = 0;
// while (i < 3) {
//   alert( `number ${i}!` );
//   i++;
// }

// let num;

// do {
//     num = prompt("Введите число больше 100?", 0);
//   } while (num <= 100 && num);

